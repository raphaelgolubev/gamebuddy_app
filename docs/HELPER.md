# Памятка для разработчика (меня)

## Соглашение о коммитах

>Note: Это работает только в идеальном мире, но все равно оставлю

https://www.conventionalcommits.org/ru/v1.0.0-beta.2/

Сообщения коммитов должны иметь следующую структуру:
```
<type>[optional область]: <краткое описание>

[optional тело]

[optional подвал]
```

Область (scope) может быть определена для любого типа коммита, чтоб описать контекст коммита. Она содержится в круглых скобках, например, ```feat(parser): add ability to parse arrays.```

- **fix**: коммит типа ``fix``, который исправляет баги в вашем коде (он соотносится с PATCH в правилах семантического управления версиями).
- **feat**: коммит type ``feat``, который добавляет новую функциональность в ваш код (он соотносится с MINOR в правилах семантического управления версиями).
- **BREAKING CHANGE**: коммит, который содержит текст ``BREAKING CHANGE``: в начале своего необязательного тела или подвала, и несет в себе описание нарушений обратной совместимости в API (он соотносится с MAJOR в правилах семантического управления версиями). BREAKING CHANGE может быть частью коммита любого типа.
- **refactor**: новой функциональности не добавлял / поведения не менял. Файлы в другие места положил, удалил, добавил. Изменил форматирование кода (white-space, formatting, missing semi-colons, etc). Улучшил алгоритм, без изменения функциональности.
- **docs**: используется при работе с документацией/readme проекта
- **test**: все, что относится к тестам
- **chore**: коммит, который не устраняет баг и не вносит новый функционал, а модифицирует или обновляет зависимости
- **style**: коммит, который вносит изменения в оформление кода
- **perf**: коммит, в котором улучшается производительность
- **revert**: коммит, который сигнализирует об откате к предыдущему коммиту

## Uvicorn
``про ювикорн``


## FastAPI
``про фастапи``



## SQLAlchemy
``про орм``



## Pydantic
``про валидацию``



## Работа с Docker
- ``docker-compose up --build`` - собрать и запустить контейнеры
- ``docker ps -a`` - список всех контейнеров
- ``docker images`` - список всех контейнеров
- ``docker history <id образа>`` - показать историю изменений образа
- ``docker system prune`` - почистить копии контейнеров и кэш
- ``docker exec -it <id контейнера> bash <команда>`` - запуск команды
- ``docker exec -it <id контейнера> python -c "import sys; print(sys.path)"`` - проверить пути
- ``docker-compose down`` - удалить контейнеры
- ``docker-compose down -v`` - удалить все контейнеры и volumes
- ``${VARIABLE_NAME}`` - в ``docker-compose.yml`` таким образом можно указать переменные из файла ``.env``

### Postgres
- ``docker exec -it <id контейнера postgres> psql -U postgres`` - провалиться внутрь postgres контейнера

### Оптимизация размера 

Оптимизация размера образа Docker может быть достигнута несколькими способами:

- Использование многоэтапной сборки (Multi-stage builds): Многоэтапная сборка позволяет создавать образы, которые содержат только необходимые для работы приложения файлы, без лишних зависимостей или средств разработки. Это позволяет существенно сократить размер образа.

- Использование минимальных базовых образов: Выбор наиболее лёгкого базового образа, такого как Alpine Linux, может существенно сократить размер конечного образа.

- Оптимизация Dockerfile: Избегайте лишних инструкций в Dockerfile, объединяйте команды в одну строку, используйте && для объединения нескольких команд в одну, чтобы избежать создания лишних слоёв.

- Использование .dockerignore: Убедитесь, что в файле .dockerignore исключены все ненужные файлы и директории из контекста сборки.

- Оптимизация слоёв образа: При создании образа убедитесь, что слои оптимизированы, чтобы избежать дублирования файлов и зависимостей. Это может быть достигнуто путём аккуратного разделения инструкций в Dockerfile.

- Удаление кэша и временных файлов: После выполнения установки зависимостей в Dockerfile убедитесь, что вы удаляете временные файлы и очищаете кэш, чтобы избежать добавления их в итоговый образ.

- Сжатие и оптимизация файлов: Перед копированием файлов в образ убедитесь, что они оптимизированы и сжаты, особенно для статических ресурсов, таких как изображения, CSS и JavaScript файлы.

- Монтирование томов для данных: Если это возможно, используйте монтирование томов Docker для данных вместо копирования их в образ, чтобы сэкономить место.

Сочетание этих методов поможет существенно уменьшить размер образа Docker.

## Чекнуть
- dev контейнеры в vscode чекнуть
- pydantic settings чекнуть